# 数据类型

## 整型

|长度	|有符号	|无符号|
|-|-|-|
|8-bit|	i8	|u8|
|16-bit|	i16	|u16|
|32-bit|	i32	|u32|
|64-bit|	i64	|u64|
|128-bit|	i128|	u128|
|arch|	isize|	usize|

整型字面量包括下面的写法

```rust
98_222 // 10进制
0xff // 16进制
0o77 // 8进制
0b1111_0000 // 2进制
```

## 浮点型

包括f32和f64，区别就在于f64的精度更高

rust中默认是f64类型的

```rust
let x = 2.0; // f64

let y: f32 = 3.0; // f32
```

## 布尔型

即true和false

```rust
let t = true;

let f: bool = false;
```

## 字符类型

> 用单引号声明char字面量

4个字节，代表了一个 Unicode 标量值，能够几乎包含所有的字符


## 字符串类型

> 用双引号声明字符串字面量

String实际上是一个`Vec<u8>` 的封装

创建字符串的方法

```rust
let mut s = String::new();

let data = "initial contents";

let s = data.to_string();

// to_string是用于任何实现了 Display trait 的类型，字符串字面值也实现了它
// 该方法也可直接用于字符串字面值：
let s = "initial contents".to_string();
```

String 的大小可以增加，其内容也可以改变

```rust
let mut s = String::from("foo");
s.push_str("bar");

// 注意拼接过程如果直接使用`+`导致的所有权问题
// 使用format就没有这个隐患
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{}-{}-{}", s1, s2, s3);
```

由于rust中字符串的字符表示任意一个unicode字符，所以每个字符实际占用的byte位数是不一样的，就像golang中的`rune`和`byte`所代表的含义一样。

rust中直接使用下标去访问字符串中的元素是会报错的

字符串转数字

```rust
let guess: u32 = "42".parse().expect("Not a number!");
```

## slice类型

允许引用集合的部分数据而不是整个集合，并且由于是引用，该类型也没有数据的所有权

字符串slice, 即String值的一部分

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```


## 元组类型

将多个其他类型的值组合, 长度固定

```rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

支持解构语法

```rust
let tup = (500, 6.4, 1);

let (x, y, z) = tup;

println!("The value of y is: {y}");
```

## 数组类型

与元组不同的是，数组类型中的元素类型必须相同，并且数组长度也是固定的

```rust
let a = [1, 2, 3, 4, 5];

// [类型; 数量]
let a: [i32; 5] = [1, 2, 3, 4, 5];

// 这里表示有5个元素每个都是3
let a = [3; 5];
```

## vector类型

与数组类似，不过vector的大小是可以改变的, 与其他struct一样，vector在其离开作用域时会被释放

```rust
let v: Vec<i32> = Vec::new();
```

如果使用初始值来创建一个Vec类型，那么Rust能够推断出储存值的类型，而无需手动标注类型

```rust
let v = vec![1, 2, 3];
```

> 如果需要对vec进行修改，需要为变量标注mut

```rust
let mut v = Vec::new();
v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

要访问vector中的元素，有通过索引访问以及通过get方法访问两种

> 第一种方法在超出索引范围时会panic

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {}", third);

match v.get(2) {
    Some(third) => println!("The third element is {}", third),
    None => println!("There is no third element."),
}

// 遍历所有元素
let v = vec![100, 32, 57];
for i in &v {
    println!("{}", i);
}

// 遍历元素的时候进行修改
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

## HashMap类型

使用方式

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
// 在键不存在的时候插入进去
scores.entry(String::from("Blue")).or_insert(50);

// 访问元素
let team_name = String::from("Blue");
let score = scores.get(&team_name);

// 遍历元素
for (key, value) in &scores {
    println!("{}: {}", key, value);
}
```

使用迭代器进行构造

```rust
use std::collections::HashMap;

let teams = vec![String::from("Blue"), String::from("Yellow")];
let initial_scores = vec![10, 50];

let mut scores: HashMap<_, _> =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
```

同样的，在使用HashMap的时候，也需要考虑所有权的问题

对于像 i32 这样的实现了 Copy trait 的类型，其值可以拷贝进哈希 map。对于像 String 这样拥有所有权的值，其值将被移动而哈希 map 会成为这些值的所有者

## 枚举类型

可以将任意类型的数据放入枚举成员中：例如字符串、数字类型、结构体,以及枚举类型

```rust
enum IpAddrKind {
    V4,
    V6,
}
```

使用

```rust
let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
```

# 指针类型

## Box<T>

box 允许你将一个值放在堆上而不是栈上。留在栈上的则是指向堆数据的指针。

```rust
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

## Deref Trait

实现 Deref trait 的智能指针可以被当作常规引用来对待

> 就是说自己定义的引用类型编译器不知道该怎么解引用

```rust
use std::ops::Deref;

struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

impl<T> Deref for MyBox<T> {
    type Target = T;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}
```

## Drop Trait

在值要离开作用域时执行一些代码，例如清理操作

```rust
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
        println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
    let c = CustomSmartPointer {
        data: String::from("my stuff"),
    };
    let d = CustomSmartPointer {
        data: String::from("other stuff"),
    };
    println!("CustomSmartPointers created.");
}
// CustomSmartPointers created.
// Dropping CustomSmartPointer with data `other stuff`!
// Dropping CustomSmartPointer with data `my stuff`!
```

## Rc<T>

只能用于单线程场景

引用计数，用于启动多所有权

> 例如图数据结构中，多个边可能指向相同的节点

如果不使用该trait，在多个引用的时候就会报所有权的问题

```rust
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&a));
    let c = Cons(4, Rc::clone(&a)); // 克隆 Rc<T> 会增加引用计数
}
```

## RefCell<T>

> 内部可变性模式，不可变值的可变借用，在数据结构中使用 unsafe 代码来模糊 Rust 通常的可变性和借用规则

只能用于单线程场景

常规情况中执行不可变值的可变借用会panic，例如下面的代码

```rust
fn main() {
    let x = 5;
    let y = &mut x;
}
// error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable
```

使用RefCell

```rust
#[derive(Debug)]
enum List {
    Cons(Rc<RefCell<i32>>, Rc<List>),
    Nil,
}

use crate::List::{Cons, Nil};
use std::cell::RefCell;
use std::rc::Rc;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(3)), Rc::clone(&a));
    let c = Cons(Rc::new(RefCell::new(4)), Rc::clone(&a));

    *value.borrow_mut() += 10;

    println!("a after = {:?}", a);
    println!("b after = {:?}", b);
    println!("c after = {:?}", c);
}
// a after = Cons(RefCell { value: 15 }, Nil)
// b after = Cons(RefCell { value: 3 }, Cons(RefCell { value: 15 }, Nil))
// c after = Cons(RefCell { value: 4 }, Cons(RefCell { value: 15 }, Nil))
```