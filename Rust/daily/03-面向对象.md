# 三大特性

面向对象的三大特征: 抽象、封装、继承

## 抽象

也就是对象，包含对象的数据与方法

Rust 是面向对象的：结构体和枚举包含数据而 impl 块提供了在结构体和枚举之上的方法。

> 虽然带有方法的结构体和枚举并不被 称为 对象，但是他们提供了与对象相同的功能

```rust
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}
```

## 封装

隐藏了实现细节

rust可以使用`pub`关键字来决定模块、类型、函数和方法是公有的，而默认情况下其他一切都是私有的

```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```

## 继承

直接继承一个父结构体使得子结构体能够调用其方法，这个在rust中无法做到。

使用继承的原因包括: 共享代码和多态

rust通过使用`trait`方法实现来进行共享以及支持多态

一般实现步骤包括

- 定义通用行为的trait
- 实现trait

> 我认为可以类比成Golang中的interface和struct，不过rust的trait有更多的公共行为

```rust
pub trait Draw {
    fn draw(&self);
}

// button实现trait
pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&self) {
        // code to actually draw a button
    }
}

// 管理struct
pub struct Screen<T: Draw> {
    pub components: Vec<T>,
}

impl<T> Screen<T>
where
    T: Draw,
{
    pub fn run(&self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
```

定义trait的时候可以提供默认实现

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)")
    }
}
```

# 泛型


示例

> 每个泛型标志所代表的泛型类型是相同的

```rust
struct Point<X1, Y1> {
    x: X1,
    y: Y1,
}

impl<X1, Y1> Point<X1, Y1> {
    fn mixup<X2, Y2>(self, other: Point<X2, Y2>) -> Point<X1, Y2> {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: "Hello", y: 'c' };

    let p3 = p1.mixup(p2);

    println!("p3.x = {}, p3.y = {}", p3.x, p3.y);
}
```